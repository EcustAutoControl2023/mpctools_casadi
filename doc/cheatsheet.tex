\documentclass{article}

\usepackage[left=.5in,right=.5in,top=.75in,bottom=.75in]{geometry}
\usepackage{mathtools,bm,textcomp,multicol,parcolumns,enumitem,array}
\usepackage[dvipsnames]{xcolor}
\usepackage[T1]{fontenc}

% Stuff for source codes.
\usepackage{listings}
\providecommand{\lstinline}{}
\lstdefinestyle{python}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{Blue}\ttfamily,
    stringstyle=\color{Purple}\ttfamily,
    commentstyle=\color{ForestGreen}\ttfamily,
    upquote=true,
    showstringspaces=false,
%    numbers=left,
    stepnumber=10,
    firstnumber=0,
    numberstyle=\scriptsize,
    escapechar=@,
    morekeywords={as},
}
\lstset{style=python}

\newcommand{\smallurl}[2][\scriptsize]{\texttt{#1$<$#2$>$}}
\newcommand{\funcname}[2][.25em]{\vspace{#1}\noindent\texttt{#2}\nopagebreak\vspace{#1}}
\newcommand{\casadi}{CasADi}

%\newcommand{\sepline}{\hrule}
\providecommand{\sepline}{\vspace{-2em}}

\title{mpc-tools-casadi Cheat Sheet}

\begin{document}

%\pagestyle{empty}
%\thispagestyle{empty}

\begin{center}
    \LARGE \texttt{mpc-tools-casadi} Cheat Sheet
\end{center}

\section{Functions Reference}

Here we present some of the most useful functions from \texttt{mpc-tools-casadi}.
These descriptions are not intended to be complete, and you should consult the documentation within the Python module for more details.

\begin{multicols}{2}

\paragraph*{Obtaining \texttt{mpc-tools-casadi}.}

The latest files can be found on \smallurl{https://hg.cae.wisc.edu/hg/mpc-tools-casadi}.
You will see a link on the left to download all of the files in a compressed archive.
No specific installation is required beyond Python and \casadi{}.

\paragraph*{Getting Started.}

Functions are arranged in a package called \texttt{mpctools}.
Typically, everything you need can be found in the main level, e.g.,
%
\begin{lstlisting}[frame=L]
import mpctools as mpc
\end{lstlisting}
%
To access older versions of functions, you can use
%
\begin{lstlisting}[frame=L]
import mpctools.legacy as mpc_old
\end{lstlisting}
%
The legacy functions are used in some of the example files, but they are being phased out because they are slower and less general.

Many functions have optional arguments or default values that aren't listed below.
Consult the docstrings throughout \texttt{mpc-tools-casadi} to see what options are available.

\paragraph*{Simulating Nonlinear Systems.}

To facilitate nonlinear simulations, we provide the \texttt{DiscreteSimulator} class, which is a wrapper a \casadi{} \texttt{Integrator} object.
To initialize, the syntax is
%
\begin{lstlisting}[frame=L]
model = OneStepSimulator(ode,Delta,argsizes)
\end{lstlisting}
%
where \texttt{ode} is a Python function that takes a fixed number of arguments whose lengths are given (in order) in the list \texttt{argsizes}.

Once the object has been built, one timestep can be simulated using
\begin{lstlisting}[frame=L]
xnext = model.sim(x,u)
\end{lstlisting}

Note that the number of arguments will vary based on how many entries you supplied in argsizes.

\paragraph*{Building \casadi{} Functions.}

To simplify creation of \casadi{} functions, there are a few convenience wrappers.

\funcname{getCasadiFunc(f,argsizes,argnames)}

Takes a Python function and sizes of arguments to build a \casadi{} \texttt{SXFunction} object.
Note that the original function \texttt{f} should return a single numpy vector (e.g., by calling \texttt{np.array} before returning).
The input \texttt{argnames} is optional, but it should be a list of strings that give variable names.
This helps make things self-documenting.

Optional arguments are available to return a Runge-Kutta discretization.
For this, you must specify \lstinline|rk4=True| and also provide arguments \texttt{Delta} with the timestep and \texttt{M} with the number of steps to take in each interval.
Example usage is shown below.

\begin{lstlisting}[frame=L]
import mpctools as mpc

# 2 states and 1 control.
def ode(x,u):
    dxdt = [x[0]**2 + u[0], x[1] - u[0]]
    return np.array(dxdt)

ode = mpc.getCasadiFunc(ode, [2,1], ["x","u"])

Delta = 0.5 # Set timestep.
ode_rk4 = mpc.getCasadiFunc(ode, [2,1], ["x","u"],
    rk4=True, Delta=Delta, M=1)
\end{lstlisting}

\funcname{getCasadiIntegrator(f,Delta,argsizes,argnames)}

Returns an \texttt{Integrator} object to integrate the Python function \texttt{f} from time 0 to \texttt{Delta}.
\texttt{argsizes} and \texttt{argnames} are the same as in \texttt{getCasadiFunc}, but the differential variables (i.e., $x$ in $dx/dt = f(x,y,z)$) must come first.

\paragraph*{Solving MPC Problems.}

For regulation problems, the function \texttt{nmpc} should be used.

\funcname{nmpc(f,l,N,x0)}

\texttt{f} and \texttt{l} should be individual \casadi{} functions to describe state evolution and stage costs.
\texttt{N} is a dictionary that holds all of the relevant sizes.
It must have entries \lstinline|"x"|, \lstinline|"u"|, and \lstinline|"t"|, all of which are integers.
\texttt{x0} is the starting state.
Additional optional arguments are given below.

\begin{itemize}[noitemsep,nolistsep]
    \item \texttt{Pf}: a single \casadi{} function of $x$ to use as a terminal cost.
    \item \texttt{lb}, \texttt{ub}, \texttt{guess}: Dictionaries with entries \lstinline@"x"@ and/or \lstinline@"u"@, to define box constraints or an initial guess for the optimal values of $x$ and $u$.
    Entries for $x$ should be a numpy array of size \lstinline@N["t"]+1@ by \lstinline@N["x"]@, and for $u$, entries should be \lstinline@N["t"]@ by \lstinline@N["u"]@.
    \item \texttt{uprev}: Value of the previous control input.
    If provided, variables $\Delta u$ will be added to the control problem.
    Bounds for $\Delta u$ can be specified as \lstinline|"Du"| entries in \texttt{lb} and \texttt{ub}.
    \item \texttt{largs}: List of strings specifying the arguments of \texttt{l} in order.
    \lstinline|"Du"| can be included in this list if you wish to use rate-of-change penalties for $u$.
    \item \texttt{verbosity}: an integer to control how detailed the solver output is.
    Lower numbers give less output.
\end{itemize}

Returns a dictionary of optimal variables and other information.
Entries include \lstinline@"x"@ and \lstinline@"u"@ with optimal trajectories for $x$ and $u$.
These are both arrays with each column corresponding to values at different time points.
Also given are \lstinline@"obj"@ with the optimal objective function value and \lstinline@"status"@ as reported by the optimizer.

For continuous-time problems, there are a few options.
To use Runge-Kutta methods, you can convert your function ahead of time (e.g., with \texttt{util.rk4} as above).
To use collocation, you can add an entry \lstinline|"c"| to the argument \texttt{N} to specify the number of collocation points on each time interval.
This also requires specifying the sample time \texttt{Delta}.

Currently, there is no support for a continuous-time objective function (i.e., continuous-time integral of a cost function).
We plan to add support for this feature in the future, but in principle you could augment your model with an integrator state to calculate the objective function.

\paragraph*{State Estimation.}

For nonlinear state estimation, we provide a moving-horizon estimation function and an Extended Kalman Filter function.

\funcname{nmhe(f,h,u,y,l,N)}

Solves a nonlinear MHE problem.
As with \texttt{nmpc}, arguments \texttt{f}, \texttt{h}, and \texttt{l} should be individual \casadi{} functions.
\texttt{f} must be $f(x,u,w)$, \texttt{h} must be $h(x)$, and \texttt{l} must be $\ell(w,v)$.
\texttt{u} and \texttt{y} must be arrays of past control inputs and measurements.
These arrays must have time running along rows so that \lstinline@y[t,:]@ gives the value of $y$ at time $t$.

Different from \texttt{nmpc}, the input \texttt{N} must be a dictionary of sizes.
This must have entries \lstinline@"t"@, \lstinline@"x"@, \lstinline@"u"@, and \lstinline@"y"@.
Note that \lstinline@N["t"]@ gives the number of time \emph{intervals}, which means \texttt{u} should have \lstinline@N["t"]@ data points, while \texttt{y} should have \lstinline@N["t"] + 1@ data points.
It may also have a \lstinline@"w"@ entry, but this is set equal to \lstinline@N["x"]@ if not supplied.
Note that for feasibility reasons, \lstinline@N["v"]@ is always set to \lstinline@N["y"]@ regardless of user input. Additional optional arguments are given below.

\begin{itemize}[noitemsep,nolistsep]
    \item \texttt{lx}, \texttt{x0bar}: arrival cost for initial state.
    \texttt{lx} should be a \casadi{} function of only $x$.
    It is included in the objective function as $\ell_x(x_0 - \overline{x}_0)$, i.e., penalizing the difference between the value of the variable $x_0$ and the prior mean $\overline{x}_0$.
    \item \texttt{lb}, \texttt{ub}, \texttt{guess}: Dictionaries to hold bounds and a guess for the decision variables.
    Same as in \texttt{nmpc}.
    \item \texttt{verbosity}: same as in \texttt{nmpc}.
\end{itemize}

\funcname{ekf(f,h,x,u,w,y,P,Q,R)}

Advances one step using the Extended Kalman Filter.
\texttt{f} and \texttt{h} must be \casadi{} functions.
\texttt{x}, \texttt{u}, \texttt{w}, and \texttt{y} should be the state estimate $\hat{x}(k|k-1)$, the controller move, the state noise (only its shape is important), and the current measurement.
\texttt{P} should be the prior covariance $P(k|k-1)$.
\texttt{Q} and \texttt{R} should be the covariances for the state noise and measurement noise.
Returns a list of
%
\begin{equation*}
    [P(k+1|k), \; \hat{x}(k+1|k), \; P(k|k), \; \hat{x}(k|k)].
\end{equation*}

\paragraph*{Steady-State Targets.}

For steady-state target selection, we provide a function \texttt{sstarg} as described below.

\funcname{sstarg(f,h,N)}

Solves a nonlinear steady-state target problem.
\texttt{f} must be $f(x,u)$ and \texttt{h} must be $h(x)$
As with the other functions, the input \texttt{N} must be a dictionary of sizes.
This must have entries \lstinline@"x"@, \lstinline@"u"@, and \lstinline@"y"@.
Additional arguments are below.

\begin{itemize}[noitemsep,nolistsep]
    \item \texttt{phi}, \texttt{phiargs}: Objective function for if the solution is non-unique.
    \texttt{phi} must be a \casadi{} function with the arguments as given in \texttt{phiargs}.
    \item \texttt{lb}, \texttt{ub}, \texttt{guess}: Dictionaries to hold bounds and a guess for the decision variables.
    Each entry must be a 1 by $n$ array, i.e., with a dummy "time" dimension first to match \texttt{nmpc} and \texttt{nmhe}.
    Note that if you want to force outputs $y$ to a specific value, you should set equal lower and upper bounds for those entries.
    \item \texttt{verbosity}: same as in \texttt{nmpc}.
\end{itemize}

\paragraph*{Time-Invariant Problems.}

If your system is time-invariant and you plan to be solving the problem repeatedly, speed can be improved by using the \texttt{ControlSolver} class.

The easiest way to build one of these objects is by setting the optional argument \texttt{runOptimization} to \texttt{False} in \texttt{nmpc}, \texttt{nmhe}, or \texttt{sstarg}.
This returns a \texttt{ControlSolver} object instead of immediately optimizing and returning the solution.
Below we list the useful methods for this class.

\funcname{fixvar(var,t,val)}

Fixes the variable named \texttt{var} to take on the value \texttt{val} at time \texttt{t}.
This is most useful for changing the initial conditions, e.g., with
%
\begin{lstlisting}[frame=L]
solver.fixvar("x",0,x0)
\end{lstlisting}
%
which allows for easy re-optimization.
You can also specify a fourth argument \texttt{inds}, if you only want to set a subset of indices for that variable (e.g., \lstinline|solver.fixvar("y",0,ysp[contVars],contVars)| to only fix the values of $y$ for controlled variables).

\funcname{solve()}

Solves the optimization problem.
Some stats (including solver success or failure) is stored into the \texttt{solver.stats} dictionary, and the optimal values of the variables are in the \texttt{solver.var} struct (e.g., \lstinline|solver.var["x",t]| gives the optimal value of $x$ at time $t$).

\funcname{saveguess()}

Takes the current solution and stores the values as a guess to the optimizer.
By default, time values are offset by 1. This is done so that
%
\begin{lstlisting}[frame=L]
solver.solve()
if solver.stats["status"] == "Solve_Succeeded":
    solver.saveguess()
    solver.fixvar("x",0,sol["x"][1,:])
\end{lstlisting}
%
prepares the solver for re-optimization at the next time point by using the final $N-1$ values of the previous trajectory as a guess for the first $N-1$ time periods in the next optimization.

\paragraph{Plotting.}

For quick plotting, we have the \texttt{mpcplot} function.
Required arguments are \texttt{x} and \texttt{u}, both 2D arrays with each row giving the value of $x$ or $u$ at a given time point, and a vector \texttt{t} of time points.
Note that \texttt{t} should have as many entries as \texttt{x} has rows, while \texttt{u} should have one fewer rows.

\paragraph*{Functions from Octave/\textsc{Matlab}.}

For convenience, we have included a few simple control-related functions from Octave/\textsc{Matlab}.

\funcname{util.dlqr(A,B,Q,R)}, \funcname[0pt]{util.dlqe(A,C,Q,R)}

Discrete-time linear-quadratic regulator and estimator.
Note that cross-penalties are not supported.

\funcname{util.c2d(A,B,Delta)}

Converts continuous-time model $(A,B)$ to discrete time with sample time \texttt{Delta}.

\end{multicols}

\section{Common Mistakes}

Below we list some common issues that may cause headaches.

\begin{itemize}
    \item NumPy arrays versus matrices.
    
    As the \texttt{matrix} data type plays second fiddle in NumPy, all of the functions have been written expecting arrays and it is suggested that you do the same.
    Any matrix multiplications within \texttt{mpc\_tools\_casadi.py} are written as \lstinline@A.dot(b)@ instead of \lstinline@A*b@ as would be common in Octave/\textsc{Matlab}.
    
    For quadratic stage costs, we provide \texttt{mtimes} (itself, just a wrapper of \casadi{}'s \texttt{mul}), which multiplies an arbitrary number of arguments.
    Unfortunately this isn't compatible with \texttt{array}s, and so you will want to cast to \casadi{}'s \texttt{DMatrix} type before multiplying.
    
    If you encounter errors such as ``\texttt{cannot cast shape (n,1) to shape (n,)}'' or something of that nature, be careful about whether you are working with 1D \texttt{arrays}, vectors stored as \texttt{matrix} objects, etc.
    This may mean adding \texttt{np.newaxis} to your assignment statements or using constructs like \lstinline@np.array(x).flatten()@ to force your data to have the right shape.
    
    \item Forgetting \casadi{} functions return lists.
    
    \casadi{} \texttt{SXFunctions} (e.g., the output of \texttt{getCasadiFunc}) always return lists, and so you will need to index the returned value to get what you want, e.g.,
    %
\begin{lstlisting}[frame=L]
z = f([x,y])[0]
\end{lstlisting}
    
    \item Poor initial guesses to solvers.
    
    By default, all variables are given guesses of 0.
    For models in deviation variables, this makes sense, but for general models, these values can cause problems, e.g., if there are divisions or logarithms any where.
    Make sure you supply an initial guess if the optimal variables are expected to be nowhere near 0, and it helps if the guess is consistent with lower and upper bounds.
    For difficult problems, it may help to solve a series of small problems to get a feasible starting guess for the large overall problem.
    
    \item Tight state constraints.
    
    Although the solvers allow constraints on all decision variables, tight constraints on the state variables (e.g., that the system terminate at the origin) can be troublesome for the solver.
    Consider using a penalty function first to get a decent guess and then re-solving with hard constraints from there.
    
\end{itemize}

\section{Example File}

Below, we present an example file to show how much code is saved by using \texttt{mpc-tools-casadi}.
On the left side, we show the the script written using the pure \texttt{casadi} module, while on the right, we show the script rewritten to use \texttt{mpc-tools-casadi}.

\hspace{1em}

\input{sidebyside.tex}

Even for this simple example, \texttt{mpc-tools-casadi} can save a significant amount of coding, and it makes script files much shorter and more readable while still taking advantage of the computational power provided by \casadi{}.

\section{Disclaimer}

Note that since \casadi{} is in active development, \texttt{mpc-tools-casadi} will need to be updated to reflect changes in \casadi{}'s Python API.
Additionally, function internals may change significantly as we identify better or more useful ways to wrap the relevant \casadi{} functions.
This means function call syntax may change, although we will strive to maintain compatibility wherever possible.

As mentioned previoiusly, the latest files can always be found on \smallurl{https://hg.cae.wisc.edu/hg/mpc-tools-casadi}.
For questions, comments, or bug reports, please contact us by email.

\begin{center}
\begin{tabular}{ccc}
    Michael J. Risbeck & Nishith R. Patel & James B. Rawlings \\
    \smallurl[\small]{risbeck@wisc.edu} & \smallurl[\small]{nrpatel@wisc.edu} & \smallurl[\small]{james.rawlings@wisc.edu} \\
    \multicolumn{3}{c}{University of Wisconsin--Madison} \\
    \hspace*{.2\textwidth} & \hspace*{.2\textwidth} & \hspace*{.2\textwidth} % Kluge alert. I hate latex tables.
\end{tabular}
\end{center}

\end{document}
